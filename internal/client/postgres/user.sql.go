// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package postgres

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users(login, password, username)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Login    string
	Password []byte
	Username string
}

// CreateUser
//
//	INSERT INTO users(login, password, username)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Login, arg.Password, arg.Username)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteUserByID = `-- name: DeleteUserByID :execrows
DELETE FROM users
WHERE id = $1
`

// DeleteUserByID
//
//	DELETE FROM users
//	WHERE id = $1
func (q *Queries) DeleteUserByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteUserByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET username=$2,
    login=$3,
    password=$4,
    avatar_id=$5,
    updated_at=now()
WHERE id = $1
`

type UpdateUserParams struct {
	ID       int64
	Username string
	Login    string
	Password []byte
	AvatarID string
}

// UpdateUser
//
//	UPDATE users
//	SET username=$2,
//	    login=$3,
//	    password=$4,
//	    avatar_id=$5,
//	    updated_at=now()
//	WHERE id = $1
func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Login,
		arg.Password,
		arg.AvatarID,
	)
	return err
}

const userByLogin = `-- name: UserByLogin :one
SELECT id, username, login, password, avatar_id, created_at, updated_at FROM users
WHERE login = $1
`

// UserByLogin
//
//	SELECT id, username, login, password, avatar_id, created_at, updated_at FROM users
//	WHERE login = $1
func (q *Queries) UserByLogin(ctx context.Context, login string) (*User, error) {
	row := q.db.QueryRow(ctx, userByLogin, login)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Login,
		&i.Password,
		&i.AvatarID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT id, username, login, password, avatar_id, created_at, updated_at FROM users
WHERE id = $1
`

// UserByUsername
//
//	SELECT id, username, login, password, avatar_id, created_at, updated_at FROM users
//	WHERE id = $1
func (q *Queries) UserByUsername(ctx context.Context, id int64) (*User, error) {
	row := q.db.QueryRow(ctx, userByUsername, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Login,
		&i.Password,
		&i.AvatarID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
