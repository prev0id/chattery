// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chat.sql

package postgres

import (
	"context"
	"time"
)

const addParticipant = `-- name: AddParticipant :exec
INSERT INTO chat_participants(chat_id, username)
VALUES ($1, $2)
`

type AddParticipantParams struct {
	ChatID   int64
	Username string
}

// AddParticipant
//
//	INSERT INTO chat_participants(chat_id, username)
//	VALUES ($1, $2)
func (q *Queries) AddParticipant(ctx context.Context, arg *AddParticipantParams) error {
	_, err := q.db.Exec(ctx, addParticipant, arg.ChatID, arg.Username)
	return err
}

const chats = `-- name: Chats :many
SELECT id, type, created_at, updated_at FROM chats
`

// Chats
//
//	SELECT id, type, created_at, updated_at FROM chats
func (q *Queries) Chats(ctx context.Context) ([]*Chat, error) {
	rows, err := q.db.Query(ctx, chats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats(type)
VALUES ($1)
RETURNING id
`

// CreateChat
//
//	INSERT INTO chats(type)
//	VALUES ($1)
//	RETURNING id
func (q *Queries) CreateChat(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRow(ctx, createChat, type_)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO chat_messages(chat_id, username, text)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateMessageParams struct {
	ChatID   int64
	Username string
	Text     string
}

// CreateMessage
//
//	INSERT INTO chat_messages(chat_id, username, text)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateMessage(ctx context.Context, arg *CreateMessageParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.ChatID, arg.Username, arg.Text)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const firstPageOfMessages = `-- name: FirstPageOfMessages :many
SELECT id, chat_id, username, text, created_at FROM chat_messages
WHERE chat_id = $1
ORDER BY created_at DESC, id DESC
LIMIT $2
`

type FirstPageOfMessagesParams struct {
	ChatID int64
	Limit  int32
}

// FirstPageOfMessages
//
//	SELECT id, chat_id, username, text, created_at FROM chat_messages
//	WHERE chat_id = $1
//	ORDER BY created_at DESC, id DESC
//	LIMIT $2
func (q *Queries) FirstPageOfMessages(ctx context.Context, arg *FirstPageOfMessagesParams) ([]*ChatMessage, error) {
	rows, err := q.db.Query(ctx, firstPageOfMessages, arg.ChatID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Username,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPagesOfMessages = `-- name: NextPagesOfMessages :many
SELECT id, chat_id, username, text, created_at FROM chat_messages
WHERE chat_id = $1 AND (created_at < $2 OR (created_at = $2 AND id < $3))
ORDER BY created_at DESC, id DESC
LIMIT $4
`

type NextPagesOfMessagesParams struct {
	ChatID    int64
	CreatedAt time.Time
	ID        int64
	Limit     int32
}

// NextPagesOfMessages
//
//	SELECT id, chat_id, username, text, created_at FROM chat_messages
//	WHERE chat_id = $1 AND (created_at < $2 OR (created_at = $2 AND id < $3))
//	ORDER BY created_at DESC, id DESC
//	LIMIT $4
func (q *Queries) NextPagesOfMessages(ctx context.Context, arg *NextPagesOfMessagesParams) ([]*ChatMessage, error) {
	rows, err := q.db.Query(ctx, nextPagesOfMessages,
		arg.ChatID,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Username,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const participantsForChat = `-- name: ParticipantsForChat :many
SELECT chat_id, username, created_at FROM chat_participants
WHERE chat_id = $1
`

// ParticipantsForChat
//
//	SELECT chat_id, username, created_at FROM chat_participants
//	WHERE chat_id = $1
func (q *Queries) ParticipantsForChat(ctx context.Context, chatID int64) ([]*ChatParticipant, error) {
	rows, err := q.db.Query(ctx, participantsForChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ChatParticipant
	for rows.Next() {
		var i ChatParticipant
		if err := rows.Scan(&i.ChatID, &i.Username, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userChats = `-- name: UserChats :many
SELECT id, type, created_at, updated_at FROM chats
WHERE chats.id in (
    SELECT chat_id FROM chat_participants
    WHERE username=$1
)
`

// UserChats
//
//	SELECT id, type, created_at, updated_at FROM chats
//	WHERE chats.id in (
//	    SELECT chat_id FROM chat_participants
//	    WHERE username=$1
//	)
func (q *Queries) UserChats(ctx context.Context, username string) ([]*Chat, error) {
	rows, err := q.db.Query(ctx, userChats, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
